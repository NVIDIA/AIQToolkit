---
description:
globs:
alwaysApply: false
---
# Creating New AIQ Tools and Workflows

## Overview

Creating new workflows involves using the `aiq workflow create` command to generate a template, then customizing the configuration object, tool function, and workflow configuration.

## Step-by-Step Process

### 1. Create Workflow Template
```bash
# Create new workflow with template
aiq workflow create --workflow-dir path/to/parent workflow_name

# Create without auto-installing
aiq workflow create --workflow-dir path/to/parent workflow_name --no-install
```

### 2. Generated Directory Structure
```
parent_dir/
└── workflow_name/
    ├── pyproject.toml
    └── src/
        └── workflow_name/
            ├── configs/
            │   └── config.yml
            ├── __init__.py
            ├── register.py
            └── workflow_name_function.py
```

### 3. Enhanced Directory Structure (Best Practice)
```
workflow_name/
├── pyproject.toml
├── config -> src/workflow_name/configs    # Symlink
├── data -> src/workflow_name/data         # Symlink
├── README.md
└── src/
    └── workflow_name/
        ├── __init__.py
        ├── configs/
        │   └── config.yml
        ├── data/                          # Create this directory
        ├── register.py
        └── workflow_name_function.py
```

## Customizing Configuration Objects

### Basic Configuration Class Pattern
```python
from aiqtoolkit.framework.config import FunctionBaseConfig
from aiqtoolkit.components.embedders.base import EmbedderRef

class YourToolConfig(FunctionBaseConfig, name="your_tool_type"):
    description: str
    # Required parameters
    input_parameter: str

    # Optional parameters with defaults
    chunk_size: int = 1024
    embedder_name: EmbedderRef = "nvidia/nv-embedqa-e5-v5"
```

### Example: Text File Ingest Tool Config
```python
class TextFileIngestToolConfig(FunctionBaseConfig, name="text_file_ingest"):
    ingest_glob: str  # Glob pattern for files to ingest
    description: str
    chunk_size: int = 1024
    embedder_name: EmbedderRef = "nvidia/nv-embedqa-e5-v5"
```

## Implementing Tool Functions

### Basic Tool Function Pattern
```python
from aiqtoolkit.framework.config import Builder
from aiqtoolkit.framework.registry import register_function
from aiqtoolkit.framework.function_info import FunctionInfo

@register_function(config_type=YourToolConfig)
async def your_tool_function(config: YourToolConfig, builder: Builder):
    # Setup and initialization
    # ...

    async def _inner(query: str) -> str:
        # Tool implementation
        return result

    yield FunctionInfo.from_fn(_inner, description=config.description)
```

### Document Processing Tool Pattern
```python
@register_function(config_type=TextFileIngestToolConfig)
async def text_file_ingest_tool(config: TextFileIngestToolConfig, builder: Builder):
    from langchain.tools.retriever import create_retriever_tool
    from langchain_community.document_loaders import DirectoryLoader, TextLoader
    from langchain_community.vectorstores import FAISS
    from langchain_text_splitters import RecursiveCharacterTextSplitter

    # Get embeddings from builder
    embeddings = await builder.get_embedder(
        config.embedder_name,
        wrapper_type=LLMFrameworkEnum.LANGCHAIN
    )

    # Load documents
    (ingest_dir, ingest_glob) = os.path.split(config.ingest_glob)
    loader = DirectoryLoader(ingest_dir, glob=ingest_glob, loader_cls=TextLoader)
    docs = [document async for document in loader.alazy_load()]

    # Process documents
    text_splitter = RecursiveCharacterTextSplitter(chunk_size=config.chunk_size)
    documents = text_splitter.split_documents(docs)
    vector = await FAISS.afrom_documents(documents, embeddings)

    # Create retriever tool
    retriever = vector.as_retriever()
    retriever_tool = create_retriever_tool(
        retriever,
        "tool_name",
        config.description,
    )

    async def _inner(query: str) -> str:
        return await retriever_tool.arun(query)

    yield FunctionInfo.from_fn(_inner, description=config.description)
```

## Common Document Loaders

### Web-based Loading
```python
from langchain_community.document_loaders import WebBaseLoader

loader = WebBaseLoader(config.webpage_url)
docs = [document async for document in loader.alazy_load()]
```

### File-based Loading
```python
from langchain_community.document_loaders import DirectoryLoader, TextLoader

# For text files
(ingest_dir, ingest_glob) = os.path.split(config.ingest_glob)
loader = DirectoryLoader(ingest_dir, glob=ingest_glob, loader_cls=TextLoader)
docs = [document async for document in loader.alazy_load()]
```

### PDF Loading
```python
from langchain_community.document_loaders import PyPDFLoader

loader = PyPDFLoader(config.pdf_path)
docs = [document async for document in loader.alazy_load()]
```

## Workflow Configuration

### Basic Configuration Structure
```yaml
functions:
  your_tool:
    _type: your_tool_type
    # Parameters matching your config class
    input_parameter: "value"
    description: "Tool description"
    chunk_size: 512
    embedder_name: nv-embedqa-e5-v5

  current_datetime:
    _type: current_datetime

llms:
  nim_llm:
    _type: nim
    model_name: meta/llama-3.1-70b-instruct
    temperature: 0.0

embedders:
  nv-embedqa-e5-v5:
    _type: nim
    model_name: nvidia/nv-embedqa-e5-v5

workflow:
  _type: react_agent
  tool_names: [your_tool, current_datetime]
  llm_name: nim_llm
  verbose: true
```

## Managing pyproject.toml

### Basic Dependencies
```toml
[project]
name = "your-workflow-name"
version = "0.1.0"
dependencies = [
    "aiqtoolkit[langchain]~=1.1",
    # Add additional dependencies as needed
]

[project.entry-points.'aiq.components']
your_workflow = "your_workflow.register"

[build-system]
requires = ["setuptools>=45", "wheel"]
build-backend = "setuptools.build_meta"
```

### Determining AIQ Version
```bash
# Check current AIQ version
aiq --version

# Use first two digits for dependency
# If version is 1.1.0, use: aiqtoolkit[langchain]~=1.1
```

### Framework-Specific Dependencies
- For LangChain: `aiqtoolkit[langchain]`
- For LlamaIndex: `aiqtoolkit[llama-index]`
- Base toolkit: `aiqtoolkit`

## Workflow Management Commands

### Installation and Updates
```bash
# Install new workflow
uv pip install -e path/to/workflow

# Reinstall after changes
aiq workflow reinstall workflow_name

# Delete workflow
aiq workflow delete workflow_name
```

### Testing
```bash
# Run workflow
aiq run --config_file path/to/config.yml --input "test question"

# Run with overrides
aiq run --config_file config.yml --input "question" --override functions.tool_name.parameter "value"
```

## Best Practices

1. **Configuration Class**:
   - Use descriptive parameter names
   - Provide sensible defaults
   - Include type hints
   - Match the `name` parameter with `_type` in YAML

2. **Tool Function**:
   - Use async functions for I/O operations
   - Handle errors gracefully
   - Log important operations
   - Use appropriate document loaders

3. **File Organization**:
   - Keep data files under `src/workflow_name/data/`
   - Use symlinks for convenience
   - Include comprehensive README.md
   - Version control all source files

4. **Testing**:
   - Test with sample data
   - Verify configuration parameters
   - Check error handling
   - Validate output format

## Common Issues and Solutions

1. **Import Errors**: Ensure all dependencies are in `pyproject.toml`
2. **Registration Issues**: Check entry points in `pyproject.toml`
3. **Configuration Mismatches**: Verify `_type` matches config class `name`
4. **Path Issues**: Use absolute paths or proper relative paths for data files
5. **Async Issues**: Ensure proper async/await usage throughout
